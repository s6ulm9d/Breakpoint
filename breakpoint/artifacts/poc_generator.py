import os
import json
import requests
import datetime
from typing import Any
from breakpoint.utils import create_folder

class PoCGenerator:
    def __init__(self, output_dir="artifacts"):
        self.output_dir = output_dir
        self.headers = {"User-Agent": "Breakpoint/PoC-Generator"}
        create_folder(output_dir)

    def generate_poc(self, vulnerability_type: str, target_url: str, payload: str, evidence: dict, method="GET", headers=None, body=None, params=None):
        """
        Generates a standalone Python script to reproduce the vulnerability.
        """
        timestamp = datetime.datetime.now().isoformat()
        safe_type = vulnerability_type.replace(" ", "_").lower()
        filename = f"poc_{safe_type}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
        full_path = os.path.join(self.output_dir, filename)

        # Heuristic for parameter name if not provided
        if method == "GET" and not params and payload:
            params = {"q": payload} # Fallback
        
        poc_content = f"""import requests
import sys
import json

# Breakpoint Auto-Generated PoC
# Date: {timestamp}
# Vulnerability: {vulnerability_type}
# Target: {target_url}

def reproduce():
    target = "{target_url}"
    method = "{method.upper()}"
    headers = {json.dumps(headers or self.headers)}
    params = {json.dumps(params or {})}
    body = {json.dumps(body or {})}
    
    print(f"[*] Reproducing {vulnerability_type} against {{target}}...")
    
    try:
        if method == "GET":
            resp = requests.get(target, params=params, headers=headers, timeout=15, verify=False)
        elif method == "POST":
            if body:
                resp = requests.post(target, json=body, headers=headers, timeout=15, verify=False)
            else:
                resp = requests.post(target, data=params, headers=headers, timeout=15, verify=False)
        else:
            resp = requests.request(method, target, headers=headers, timeout=15, verify=False)
            
        print(f"[+] Status Code: {{resp.status_code}}")
        
        # Check for evidence signature
        signature = "{evidence.get('signature', '')}"
        if signature and signature in resp.text:
            print("[!] Vulnerability Confirmed via Signature Match!")
        elif resp.status_code >= 500:
            print("[!] Vulnerability Confirmed via Server Error (Potential Crash/Injection)!")
        else:
            print("[-] Attack might have been blocked or patched (Signature not found).")

    except Exception as e:
        print(f"[-] Error executing PoC: {{e}}")

if __name__ == "__main__":
    from requests.packages.urllib3.exceptions import InsecureRequestWarning
    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
    reproduce()
"""
        with open(full_path, "w") as f:
            f.write(poc_content)
        
        return full_path

    def save_llm_poc(self, vulnerability_type: str, poc_code: str):
        """
        Saves a PoC generated by the Adversarial Loop.
        """
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_type = vulnerability_type.replace(" ", "_").lower()
        filename = f"poc_verified_{safe_type}_{timestamp}.py"
        full_path = os.path.join(self.output_dir, filename)
        
        with open(full_path, "w") as f:
            f.write(poc_code)
        
        return full_path

class ArtifactManager:
    def __init__(self, base_dir="artifacts"):
        self.base_dir = base_dir
        create_folder(base_dir)

    def save_artifact(self, name: str, content: Any, type="json"):
        path = os.path.join(self.base_dir, f"{name}.{type}")
        with open(path, "w") as f:
            if type == "json":
                json.dump(content, f, indent=2)
            else:
                f.write(content)
        return path
